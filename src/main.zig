//! Advent of Code 2025 - Main Entry Point
//!
//! This is the CLI dispatcher that handles command-line arguments and
//! routes execution to the appropriate day's solution.
//!
//! Usage:
//!   zig build run -- <day> [part]
//!   zig build run -- all
//!   zig build run  (runs all days)

const std = @import("std");
const utils = @import("utils");

// Import the auto-generated days module (created by build.zig)
// This module contains imports for all discovered day solutions
const days = @import("days.zig");

pub fn main() !void {
    // Set up memory allocator
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Get command line arguments
    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    // Parse and execute based on arguments
    if (args.len == 1) {
        // No arguments: run all implemented days
        try runAll(allocator);
    } else if (std.mem.eql(u8, args[1], "all")) {
        // Explicit "all" command
        try runAll(allocator);
    } else {
        // Parse day number
        const day = std.fmt.parseInt(u8, args[1], 10) catch {
            std.debug.print("Error: Invalid day number '{s}'\n", .{args[1]});
            std.debug.print("Usage: aoc2025 <day> [part]\n", .{});
            std.debug.print("       aoc2025 all\n", .{});
            std.process.exit(1);
        };

        // Parse optional part number
        const part: ?u8 = if (args.len > 2)
            std.fmt.parseInt(u8, args[2], 10) catch {
                std.debug.print("Error: Invalid part number '{s}'\n", .{args[2]});
                std.debug.print("Part must be 1 or 2\n", .{});
                std.process.exit(1);
            }
        else
            null;

        // Validate part number if provided
        if (part) |p| {
            if (p != 1 and p != 2) {
                std.debug.print("Error: Part must be 1 or 2, got {}\n", .{p});
                std.process.exit(1);
            }
        }

        // Run the requested day
        runDay(allocator, day, part) catch |err| {
            std.debug.print("Error running day {}: {}\n", .{ day, err });
            std.process.exit(1);
        };
    }
}

/// Run all implemented days
fn runAll(allocator: std.mem.Allocator) !void {
    std.debug.print("Running all implemented days...\n\n", .{});

    // The days.implemented_days array is auto-generated by build.zig
    for (days.implemented_days) |day| {
        runDay(allocator, day, null) catch |err| {
            std.debug.print("Error running day {}: {}\n", .{ day, err });
            continue;
        };
        std.debug.print("\n", .{});
    }

    std.debug.print("All days completed!\n", .{});
}

/// Run a specific day (and optionally a specific part)
fn runDay(allocator: std.mem.Allocator, day: u8, part: ?u8) !void {
    // Read the input file for this day
    const input = utils.readInputFile(allocator, day) catch |err| {
        std.debug.print("Error reading input for day {}: {}\n", .{ day, err });
        std.debug.print("Make sure inputs/day{d:0>2}.txt exists\n", .{day});
        return err;
    };
    defer allocator.free(input);

    // Format the day name for output
    const day_name = try std.fmt.allocPrint(allocator, "Day {}", .{day});
    defer allocator.free(day_name);

    // Dispatch to the appropriate day's solution
    // The days.runDay function is auto-generated by build.zig
    try days.runDay(allocator, day, part, input, day_name);
}
